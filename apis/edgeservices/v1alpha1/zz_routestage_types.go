/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PathFilterInitParameters struct {

	// The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the regex type.
	// The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type
	PathFilterType *string `json:"pathFilterType,omitempty" tf:"path_filter_type,omitempty"`

	// The value to be matched for the HTTP URL path.
	// The value to be matched for the HTTP URL path
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PathFilterObservation struct {

	// The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the regex type.
	// The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type
	PathFilterType *string `json:"pathFilterType,omitempty" tf:"path_filter_type,omitempty"`

	// The value to be matched for the HTTP URL path.
	// The value to be matched for the HTTP URL path
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PathFilterParameters struct {

	// The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the regex type.
	// The type of filter to match for the HTTP URL path. For now, all path filters must be written in regex and use the `regex` type
	// +kubebuilder:validation:Optional
	PathFilterType *string `json:"pathFilterType" tf:"path_filter_type,omitempty"`

	// The value to be matched for the HTTP URL path.
	// The value to be matched for the HTTP URL path
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type RouteStageInitParameters struct {

	// The ID of the pipeline.
	// The ID of the pipeline
	// +crossplane:generate:reference:type=github.com/scaleway/crossplane-provider-scaleway/apis/edgeservices/v1alpha1.Pipeline
	PipelineID *string `json:"pipelineId,omitempty" tf:"pipeline_id,omitempty"`

	// Reference to a Pipeline in edgeservices to populate pipelineId.
	// +kubebuilder:validation:Optional
	PipelineIDRef *v1.Reference `json:"pipelineIdRef,omitempty" tf:"-"`

	// Selector for a Pipeline in edgeservices to populate pipelineId.
	// +kubebuilder:validation:Optional
	PipelineIDSelector *v1.Selector `json:"pipelineIdSelector,omitempty" tf:"-"`

	// (Defaults to provider project_id) The ID of the project the route stage is associated with.
	// The project_id you want to attach the resource to
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The list of rules to be checked against every HTTP request. The first matching rule will forward the request to its specified backend stage. If no rules are matched, the request is forwarded to the WAF stage defined by waf_stage_id.
	// List of rules to be checked against every HTTP request. The first matching rule will forward the request to its specified backend stage. If no rules are matched, the request is forwarded to the WAF stage defined by `waf_stage_id`
	Rule []RuleInitParameters `json:"rule,omitempty" tf:"rule,omitempty"`

	// The ID of the WAF stage HTTP requests should be forwarded to when no rules are matched.
	// The ID of the WAF stage HTTP requests should be forwarded to when no rules are matched
	// +crossplane:generate:reference:type=github.com/scaleway/crossplane-provider-scaleway/apis/edgeservices/v1alpha1.WAFStage
	WafStageID *string `json:"wafStageId,omitempty" tf:"waf_stage_id,omitempty"`

	// Reference to a WAFStage in edgeservices to populate wafStageId.
	// +kubebuilder:validation:Optional
	WafStageIDRef *v1.Reference `json:"wafStageIdRef,omitempty" tf:"-"`

	// Selector for a WAFStage in edgeservices to populate wafStageId.
	// +kubebuilder:validation:Optional
	WafStageIDSelector *v1.Selector `json:"wafStageIdSelector,omitempty" tf:"-"`
}

type RouteStageObservation struct {

	// The date and time of the creation of the route stage.
	// The date and time of the creation of the route stage
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// The ID of the route stage (UUID format).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The ID of the pipeline.
	// The ID of the pipeline
	PipelineID *string `json:"pipelineId,omitempty" tf:"pipeline_id,omitempty"`

	// (Defaults to provider project_id) The ID of the project the route stage is associated with.
	// The project_id you want to attach the resource to
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The list of rules to be checked against every HTTP request. The first matching rule will forward the request to its specified backend stage. If no rules are matched, the request is forwarded to the WAF stage defined by waf_stage_id.
	// List of rules to be checked against every HTTP request. The first matching rule will forward the request to its specified backend stage. If no rules are matched, the request is forwarded to the WAF stage defined by `waf_stage_id`
	Rule []RuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`

	// The date and time of the last update of the route stage.
	// The date and time of the last update of the route stage
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`

	// The ID of the WAF stage HTTP requests should be forwarded to when no rules are matched.
	// The ID of the WAF stage HTTP requests should be forwarded to when no rules are matched
	WafStageID *string `json:"wafStageId,omitempty" tf:"waf_stage_id,omitempty"`
}

type RouteStageParameters struct {

	// The ID of the pipeline.
	// The ID of the pipeline
	// +crossplane:generate:reference:type=github.com/scaleway/crossplane-provider-scaleway/apis/edgeservices/v1alpha1.Pipeline
	// +kubebuilder:validation:Optional
	PipelineID *string `json:"pipelineId,omitempty" tf:"pipeline_id,omitempty"`

	// Reference to a Pipeline in edgeservices to populate pipelineId.
	// +kubebuilder:validation:Optional
	PipelineIDRef *v1.Reference `json:"pipelineIdRef,omitempty" tf:"-"`

	// Selector for a Pipeline in edgeservices to populate pipelineId.
	// +kubebuilder:validation:Optional
	PipelineIDSelector *v1.Selector `json:"pipelineIdSelector,omitempty" tf:"-"`

	// (Defaults to provider project_id) The ID of the project the route stage is associated with.
	// The project_id you want to attach the resource to
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The list of rules to be checked against every HTTP request. The first matching rule will forward the request to its specified backend stage. If no rules are matched, the request is forwarded to the WAF stage defined by waf_stage_id.
	// List of rules to be checked against every HTTP request. The first matching rule will forward the request to its specified backend stage. If no rules are matched, the request is forwarded to the WAF stage defined by `waf_stage_id`
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule,omitempty" tf:"rule,omitempty"`

	// The ID of the WAF stage HTTP requests should be forwarded to when no rules are matched.
	// The ID of the WAF stage HTTP requests should be forwarded to when no rules are matched
	// +crossplane:generate:reference:type=github.com/scaleway/crossplane-provider-scaleway/apis/edgeservices/v1alpha1.WAFStage
	// +kubebuilder:validation:Optional
	WafStageID *string `json:"wafStageId,omitempty" tf:"waf_stage_id,omitempty"`

	// Reference to a WAFStage in edgeservices to populate wafStageId.
	// +kubebuilder:validation:Optional
	WafStageIDRef *v1.Reference `json:"wafStageIdRef,omitempty" tf:"-"`

	// Selector for a WAFStage in edgeservices to populate wafStageId.
	// +kubebuilder:validation:Optional
	WafStageIDSelector *v1.Selector `json:"wafStageIdSelector,omitempty" tf:"-"`
}

type RuleHTTPMatchInitParameters struct {

	// HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are get, post, put, patch, delete, head, options. All methods will match if none is provided.
	// HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided
	MethodFilters []*string `json:"methodFilters,omitempty" tf:"method_filters,omitempty"`

	// HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
	// HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided
	PathFilter []PathFilterInitParameters `json:"pathFilter,omitempty" tf:"path_filter,omitempty"`
}

type RuleHTTPMatchObservation struct {

	// HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are get, post, put, patch, delete, head, options. All methods will match if none is provided.
	// HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided
	MethodFilters []*string `json:"methodFilters,omitempty" tf:"method_filters,omitempty"`

	// HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
	// HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided
	PathFilter []PathFilterObservation `json:"pathFilter,omitempty" tf:"path_filter,omitempty"`
}

type RuleHTTPMatchParameters struct {

	// HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are get, post, put, patch, delete, head, options. All methods will match if none is provided.
	// HTTP methods to filter for. A request using any of these methods will be considered to match the rule. Possible values are `get`, `post`, `put`, `patch`, `delete`, `head`, `options`. All methods will match if none is provided
	// +kubebuilder:validation:Optional
	MethodFilters []*string `json:"methodFilters,omitempty" tf:"method_filters,omitempty"`

	// HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided.
	// HTTP URL path to filter for. A request whose path matches the given filter will be considered to match the rule. All paths will match if none is provided
	// +kubebuilder:validation:Optional
	PathFilter []PathFilterParameters `json:"pathFilter,omitempty" tf:"path_filter,omitempty"`
}

type RuleInitParameters struct {

	// The ID of the backend stage that requests matching the rule should be forwarded to.
	// ID of the backend stage that requests matching the rule should be forwarded to
	// +crossplane:generate:reference:type=github.com/scaleway/crossplane-provider-scaleway/apis/edgeservices/v1alpha1.BackendStage
	BackendStageID *string `json:"backendStageId,omitempty" tf:"backend_stage_id,omitempty"`

	// Reference to a BackendStage in edgeservices to populate backendStageId.
	// +kubebuilder:validation:Optional
	BackendStageIDRef *v1.Reference `json:"backendStageIdRef,omitempty" tf:"-"`

	// Selector for a BackendStage in edgeservices to populate backendStageId.
	// +kubebuilder:validation:Optional
	BackendStageIDSelector *v1.Selector `json:"backendStageIdSelector,omitempty" tf:"-"`

	// The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the backend_stage_id field. Requests that do not match will be checked by the next rule's condition.
	// Rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition
	RuleHTTPMatch []RuleHTTPMatchInitParameters `json:"ruleHttpMatch,omitempty" tf:"rule_http_match,omitempty"`
}

type RuleObservation struct {

	// The ID of the backend stage that requests matching the rule should be forwarded to.
	// ID of the backend stage that requests matching the rule should be forwarded to
	BackendStageID *string `json:"backendStageId,omitempty" tf:"backend_stage_id,omitempty"`

	// The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the backend_stage_id field. Requests that do not match will be checked by the next rule's condition.
	// Rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition
	RuleHTTPMatch []RuleHTTPMatchObservation `json:"ruleHttpMatch,omitempty" tf:"rule_http_match,omitempty"`
}

type RuleParameters struct {

	// The ID of the backend stage that requests matching the rule should be forwarded to.
	// ID of the backend stage that requests matching the rule should be forwarded to
	// +crossplane:generate:reference:type=github.com/scaleway/crossplane-provider-scaleway/apis/edgeservices/v1alpha1.BackendStage
	// +kubebuilder:validation:Optional
	BackendStageID *string `json:"backendStageId,omitempty" tf:"backend_stage_id,omitempty"`

	// Reference to a BackendStage in edgeservices to populate backendStageId.
	// +kubebuilder:validation:Optional
	BackendStageIDRef *v1.Reference `json:"backendStageIdRef,omitempty" tf:"-"`

	// Selector for a BackendStage in edgeservices to populate backendStageId.
	// +kubebuilder:validation:Optional
	BackendStageIDSelector *v1.Selector `json:"backendStageIdSelector,omitempty" tf:"-"`

	// The rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the backend_stage_id field. Requests that do not match will be checked by the next rule's condition.
	// Rule condition to be matched. Requests matching the condition defined here will be directly forwarded to the backend specified by the `backend_stage_id` field. Requests that do not match will be checked by the next rule's condition
	// +kubebuilder:validation:Optional
	RuleHTTPMatch []RuleHTTPMatchParameters `json:"ruleHttpMatch,omitempty" tf:"rule_http_match,omitempty"`
}

// RouteStageSpec defines the desired state of RouteStage
type RouteStageSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RouteStageParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RouteStageInitParameters `json:"initProvider,omitempty"`
}

// RouteStageStatus defines the observed state of RouteStage.
type RouteStageStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RouteStageObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// RouteStage is the Schema for the RouteStages API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,scaleway}
type RouteStage struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RouteStageSpec   `json:"spec"`
	Status            RouteStageStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RouteStageList contains a list of RouteStages
type RouteStageList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RouteStage `json:"items"`
}

// Repository type metadata.
var (
	RouteStage_Kind             = "RouteStage"
	RouteStage_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RouteStage_Kind}.String()
	RouteStage_KindAPIVersion   = RouteStage_Kind + "." + CRDGroupVersion.String()
	RouteStage_GroupVersionKind = CRDGroupVersion.WithKind(RouteStage_Kind)
)

func init() {
	SchemeBuilder.Register(&RouteStage{}, &RouteStageList{})
}
