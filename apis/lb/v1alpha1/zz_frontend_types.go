/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ACLObservation struct {
}

type ACLParameters struct {

	// Action to undertake when an ACL filter matches.
	// Action to undertake when an ACL filter matches
	// +kubebuilder:validation:Required
	Action []ActionParameters `json:"action" tf:"action,omitempty"`

	// The ACL match rule. At least ip_subnet or http_filter and http_filter_value are required.
	// The ACL match rule
	// +kubebuilder:validation:Required
	Match []MatchParameters `json:"match" tf:"match,omitempty"`

	// The ACL name. If not provided it will be randomly generated.
	// The ACL name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ActionObservation struct {
}

type ActionParameters struct {

	// The action type. Possible values are: allow or deny.
	// The action type
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type FrontendObservation struct {

	// (Deprecated) first certificate ID used by the frontend.
	// Certificate ID
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// The ID of the load-balancer frontend.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type FrontendParameters struct {

	// A list of ACL rules to apply to the load-balancer frontend.  Defined below.
	// ACL rules
	// +kubebuilder:validation:Optional
	ACL []ACLParameters `json:"acl,omitempty" tf:"acl,omitempty"`

	// The load-balancer backend ID this frontend is attached to.
	// The load-balancer backend ID
	// +crossplane:generate:reference:type=Backend
	// +kubebuilder:validation:Optional
	BackendID *string `json:"backendId,omitempty" tf:"backend_id,omitempty"`

	// Reference to a Backend to populate backendId.
	// +kubebuilder:validation:Optional
	BackendIDRef *v1.Reference `json:"backendIdRef,omitempty" tf:"-"`

	// Selector for a Backend to populate backendId.
	// +kubebuilder:validation:Optional
	BackendIDSelector *v1.Selector `json:"backendIdSelector,omitempty" tf:"-"`

	// List of Certificate IDs that should be used by the frontend.
	// Collection of Certificate IDs related to the load balancer and domain
	// +kubebuilder:validation:Optional
	CertificateIds []*string `json:"certificateIds,omitempty" tf:"certificate_ids,omitempty"`

	// (Default: false) Activates HTTP/3 protocol.
	// Activates HTTP/3 protocol
	// +kubebuilder:validation:Optional
	EnableHttp3 *bool `json:"enableHttp3,omitempty" tf:"enable_http3,omitempty"`

	// TCP port to listen on the front side.
	// TCP port to listen on the front side
	// +kubebuilder:validation:Required
	InboundPort *float64 `json:"inboundPort" tf:"inbound_port,omitempty"`

	// The load-balancer ID this frontend is attached to.
	// The load-balancer ID
	// +crossplane:generate:reference:type=LB
	// +kubebuilder:validation:Optional
	LBID *string `json:"lbId,omitempty" tf:"lb_id,omitempty"`

	// Reference to a LB to populate lbId.
	// +kubebuilder:validation:Optional
	LBIDRef *v1.Reference `json:"lbIdRef,omitempty" tf:"-"`

	// Selector for a LB to populate lbId.
	// +kubebuilder:validation:Optional
	LBIDSelector *v1.Selector `json:"lbIdSelector,omitempty" tf:"-"`

	// The name of the load-balancer frontend.
	// The name of the frontend
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Maximum inactivity time on the client side. (e.g.: 1s)
	// Set the maximum inactivity time on the client side
	// +kubebuilder:validation:Optional
	TimeoutClient *string `json:"timeoutClient,omitempty" tf:"timeout_client,omitempty"`
}

type MatchObservation struct {
}

type MatchParameters struct {

	// The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
	// It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
	// Possible values are: acl_http_filter_none, path_begin, path_end, http_header_match or regex.
	// The HTTP filter to match
	// +kubebuilder:validation:Optional
	HTTPFilter *string `json:"httpFilter,omitempty" tf:"http_filter,omitempty"`

	// You can use this field with http_header_match acl type to set the header name to filter
	// +kubebuilder:validation:Optional
	HTTPFilterOption *string `json:"httpFilterOption,omitempty" tf:"http_filter_option,omitempty"`

	// A list of possible values to match for the given HTTP filter.
	// Keep in mind that in the case of http_header_match the HTTP header field name is case-insensitive.
	// A list of possible values to match for the given HTTP filter
	// +kubebuilder:validation:Optional
	HTTPFilterValue []*string `json:"httpFilterValue,omitempty" tf:"http_filter_value,omitempty"`

	// A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
	// A list of IPs or CIDR v4/v6 addresses of the client of the session to match
	// +kubebuilder:validation:Optional
	IPSubnet []*string `json:"ipSubnet,omitempty" tf:"ip_subnet,omitempty"`

	// If set to true, the condition will be of type "unless".
	// If set to true, the condition will be of type "unless"
	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`
}

// FrontendSpec defines the desired state of Frontend
type FrontendSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FrontendParameters `json:"forProvider"`
}

// FrontendStatus defines the observed state of Frontend.
type FrontendStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FrontendObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Frontend is the Schema for the Frontends API. Manages Scaleway Load-Balancer Frontends.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,scaleway}
type Frontend struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FrontendSpec   `json:"spec"`
	Status            FrontendStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FrontendList contains a list of Frontends
type FrontendList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Frontend `json:"items"`
}

// Repository type metadata.
var (
	Frontend_Kind             = "Frontend"
	Frontend_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Frontend_Kind}.String()
	Frontend_KindAPIVersion   = Frontend_Kind + "." + CRDGroupVersion.String()
	Frontend_GroupVersionKind = CRDGroupVersion.WithKind(Frontend_Kind)
)

func init() {
	SchemeBuilder.Register(&Frontend{}, &FrontendList{})
}
